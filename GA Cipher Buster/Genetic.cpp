#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
#include <vector>
#include <random>
#include "Member.h"
#include "Genetic.h"


Genetic::Genetic()
{

}


bool Genetic::crossoverProb()
{
	//get random number, if the number is odd, then the members will be crossed over and so true is returned
	//otherwise return false
	std::random_device device;
	std::mt19937 generator(device());
	std::uniform_int_distribution<int> distribution(0, 100000);
	int prob = distribution(generator) % 4;//distribution(generator) % 2;

	if (prob == 0)
		return true;
	else
		return false;
}


bool Genetic::mutateProb()
{
	//get random number, if the number is odd, then the member will be mutated and so true is returned
	//otherwise return false
	std::random_device device;
	std::mt19937 generator(device());
	std::uniform_int_distribution<int> distribution(0, 100000);
	int prob = distribution(generator) % 4;//distribution(generator) % 2;

	if (prob == 0)
		return true;
	else
		return false;
}


bool Genetic::isPopulationSet()
{
	if (population.empty())
		return false;
	else
		return true;

}


double Genetic::calculateMemberFitness(Member current)
{
	//create a second contact table that contains the values generated by the current key
	int currentContactTable[26][26] = { 0 };
	int currentContactTableElements = 0;
	
	//attempt to decipher the code using the key provided
	std::string attemptedMessage = decipheredCode(current);


	//then count the occurance of every combination of two letters
	int x =0, y=0;
	for (int firstLetter = 0; firstLetter < attemptedMessage.size() - 1; firstLetter++)
	{
		int secondLetter = firstLetter + 1; 
		char currentFirstLetter = attemptedMessage.at(firstLetter);		
		char currentSecondLetter = attemptedMessage.at(secondLetter);
		std::string compare;
		compare = currentFirstLetter + currentSecondLetter;


		//find out what letter each one is and set the location, then add it the slot
		for (int english = 0; english < englishKey.size(); english++)
		{
			if (currentFirstLetter == englishKey.at(english))
				x = english;

			if (currentSecondLetter == englishKey.at(english))
				y = english;
		}
		currentContactTable[x][y] += 1;
		currentContactTableElements++;
	}
	

	//display contact table as a test
	//if (debugFitness)
	//{	
	//	for (int y = 0; y < englishKey.size(); y++)
	//	{
	//		std::cout << englishKey.at(y) << "    ";
	//		for (int x = 0; x < englishKey.size(); x++)
	//		{
	//			std::cout << std::left << std::setw(5) << currentContactTable[x][y];
	//		}
	//		std::cout << std::endl;
	//	}

	//	std::cout << "Current message has " << currentContactTableElements << " characters, and example contact table uses "
	//		<< contactTableElements << std::endl << std::endl;
	//}

	////scale the numbers of the two contact tables by using the total number of elements
	//double scale = contactTableElements / currentContactTableElements;
	//for (int y = 0; y < englishKey.size(); y++)
	//{
	//	for (int x = 0; x < englishKey.size(); x++)
	//	{
	//		currentContactTable[x][y] = currentContactTable[x][y] * scale;
	//	}
	//}

	//if (debugFitness)
	//{
	//	for (int y = 0; y < englishKey.size(); y++)
	//	{
	//		std::cout << englishKey.at(y) << "    ";
	//		for (int x = 0; x < englishKey.size(); x++)
	//		{
	//			std::cout << std::left << std::setw(5) << currentContactTable[x][y];
	//		}
	//		std::cout << std::endl;
	//	}

	//	std::cout << "Scaled out numbers using total counts from both tables" << std::endl << std::endl;
	//}


	//then calculate the actual fitness by comparing the table generated using the current key to the english alphabet contact table
	int currentMemberFitness = 0;
	for (int r = 0; r < 26; r++)
	{
		for (int c = 0; c < 26; c++)
		{
			int temp = (contactTable[c][r] - currentContactTable[c][r]);
			temp = temp * temp;
			currentMemberFitness += temp;
		}
	}

	return currentMemberFitness;
}


std::string Genetic::returnMessage()
{
	std::string returnDecipheredMessage = "";
	for (int blockCount = 0; blockCount < cypheredMessage.size(); blockCount++)
	{
		for (int size = 0; size < cypheredMessage.at(blockCount).size(); size++)
		{
			returnDecipheredMessage += cypheredMessage.at(blockCount).at(size);
		}
	}
	//std::cout << returnDecipheredMessage << std::endl; 
	
	return returnDecipheredMessage;

	
}


std::string Genetic::decipheredCode(Member current)
{
	std::string currentKey = current.cipherKey;
	std::string translatedMessage = returnMessage();
	std::vector<bool> isMessageCyphered;
	for (int elements = 0; elements < translatedMessage.size(); elements++)
	{
		isMessageCyphered.push_back(true);
	}
	
	for (int i = 0; i < 26; i++)
	{
		char currentEnglish = englishKey.at(i);
		char currentLetter = currentKey.at(i);
		//std::cout << "Current member key: " << currentKey << " vs english alphabet: " << englishKey << std::endl;

		for (int counter = 0; counter < translatedMessage.size(); counter++)
		{
			if (translatedMessage.at(counter) == currentLetter && isMessageCyphered.at(counter))
			{
				//std::cout << "TRUE, current letter is " << currentLetter << " and it should be a " << currentEnglish << std::endl;

				translatedMessage.at(counter) = currentEnglish;
				isMessageCyphered.at(counter) = false;
			}
		}
	}


	//then display new message
	return translatedMessage;

}


double Genetic::calculatePopulationFitness()
{
	double totalFitness = 0;

	for (int c = 0; c < population.size(); c++)
	{
		totalFitness += population.at(c).fitness;
	}

	totalFitness = totalFitness / population.size();

	return totalFitness;
}


void Genetic::displayPopulationFitness()
{
	for (int c = 0; c < population.size(); c++)
	{
		std::cout << population.at(c).cipherKey << " yields a fitness score of " << population.at(c).fitness << std::endl;
	}
}


double Genetic::bestFitnessInPopulation()
{
	//new version - finds the worst member and replaces it if better
	int bestLocation = 0;
	double bestFitness = population.at(bestLocation).fitness;

	for (int count = 0; count < population.size(); count++)
	{
		if (population.at(count).fitness < bestFitness)
		{
			bestFitness = population.at(count).fitness;
			bestLocation = count;
		}
	}

	return bestFitness;
}


void Genetic::insert(Member current)
{
	//this can be done a few ways, either totally random or selecting the worst and replacing it with the new one
	
	
	//totally random
	/*std::random_device device;
	std::mt19937 generator(device());
	std::uniform_int_distribution<int> distribution(0, population.size() - 1);
	int spot = distribution(generator);
	population.at(spot) = current;*/


	//replacing worst
	int worstLocation = 0;
	double worstFitness = population.at(worstLocation).fitness;

	for (int count = 1; count < population.size(); count++)
	{
		if (population.at(count).fitness > worstFitness)
		{
			worstFitness = population.at(count).fitness;
			worstLocation = count;
		}
	}

	//if the current member is better, replace the worst one
	if (current.fitness < worstFitness)
	{
		population.at(worstLocation) = current;
	}
}


void Genetic::initializePopulationUnique(int memberCount)
{
	populationsize = memberCount;
	population.clear();
	
	for (int counter = 0; counter < populationsize; counter++)
	{
		Member x0 = Member(englishKey);
		for (int random = 0; random < 7; random++)
			x0.mutate();
		x0.fitness = calculateMemberFitness(x0);
		population.push_back(x0);
	}
	
	/*else
	{
		for (int counter = 0; counter < populationsize; counter++)
		{
			Member x0 = population.at(counter);
			for (int random = 0; random < 5; random++)
				x0.mutate();
			x0.fitness = calculateMemberFitness(x0);
			population.at(counter) = x0;
		}
	}*/


	//displayPopulation();
}


void Genetic::initializePopulation()
{
	std::string start;
	for (int s = 0; s < 26; s++)
	{
		start.push_back(englishKey.at(s));
	}

	for (int a = 0; a < populationsize; a++)
	{
		Member current(start);
		current.fitness = calculateMemberFitness(current);
		population.push_back(current);
		//if (debug) { std::cout << "Member " << a << " added: " << current.cipherKey << std::endl; }
	}
}


void Genetic::initializeContactTable(std::string filename)
{
	using namespace std;

	//open file
	ifstream inputFile;

	contactTableElements = 0;

	inputFile.open(filename);
	if (inputFile.is_open())
	{
		cout << "File \"" << filename << "\" has been opened" << endl;
		string temp, trash;
		
		//english alphabet key - used to assign each letter a number value
		
		
		while (!inputFile.eof())
		{
			//once the file is opened, get the first two characters - this way the contact values can be stored properly
			getline(inputFile, temp, ' ');
			char first = temp.at(0);
			char second = temp.at(1);

			//the next value is the number
			getline(inputFile, temp, '\n');
			int contactValue = stoi(temp);

			//convert all values to lower if not already
			if (islower(first)) { first = toupper(first); }
			if (islower(second)) { second = toupper(second); }
			int x, y;

			//convert all letters to numbers
			for (int w = 0; w < englishKey.size(); w++)
			{
				if (first == englishKey[w])
				{
					int letterValue = (int)(englishKey[w] - 'A');
					x = letterValue;
				}

				if (second == englishKey[w])
				{
					int letterValue = (int)(englishKey[w] - 'A');
					y = letterValue;
				}
			}

			//add the value to the contact table matrix
			contactTable[x][y] = contactValue;
			contactTableElements += contactValue;
			contactValue = 0;
		}
	}
}


void Genetic::initializeCode(std::string filename)
{
	using namespace std;
	codedMessageElements = 0;

	if (filename == "p1209.code")
		populationFitnessThreshold = 3406;
	else if (filename == "test.code" || filename == "o715.code")
		populationFitnessThreshold = 2850;
	else
		populationFitnessThreshold = 5000;

	//open file
	ifstream inputFile;
	inputFile.open(filename);
	
	if (inputFile.is_open())
	{
		cout << "File \"" << filename << "\" has been opened" << endl;
		string temp, trash;
		int spacing = 1;

		while (!inputFile.eof())
		{
			//create 5 char blocks of the cyphered message and then push these blocks onto the cypher message vector
			//because there are 10 blocks on each line, make sure that all blocks are read
			if(spacing < 10)
				getline(inputFile, temp, ' ');
			else if (spacing == 10)
			{
				getline(inputFile, temp, '\n');
				spacing = 0;
			}

			//add the block to the total cyphered message and increment the counter
			for (int blockSize = 0; blockSize < temp.size(); blockSize++)
			{
				//isMessageCyphered.push_back(true);
				if (islower(temp.at(blockSize)))
				{
					temp.at(blockSize) = toupper(temp.at(blockSize));
				}
			}

			cypheredMessage.push_back(temp);
			codedMessageElements += temp.size();
			spacing++;
		}

	}
	else { cout << "File \"" << filename << "\" could not be opened" << endl; }

}


void Genetic::normalizeContactTable()
{
	double scale = contactTableElements / codedMessageElements;
	

	for (int y = 0; y < englishKey.size(); y++)
	{
		for (int x = 0; x < englishKey.size(); x++)
		{
			contactTable[x][y] /= scale;
		}
	}
}


void Genetic::displayContactTable()
{
	std::string key = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	std::cout << " ";

	for (int i = 0; i < 26; i++)
	{
		std::cout << "    " << key[i];
	}
	std::cout << std::endl;


	for (int y = 0; y < 26; y++)
	{
		std::cout << key[y] << "   ";
		for (int x = 0; x < 26; x++)
		{
			std::cout << std::left << std::setw(5) << contactTable[x][y];
		}
		std::cout << std::endl;
	}
}


void Genetic::displayPopulation()
{
	if (!population.empty())
	{
		//if (debug) { std::cout << "Population is not empty" << std::endl; }

		for (int i = 0; i < populationsize; i++)
		{
			Member current = population.at(i);
			std::cout << "Member " << i << " key: " << current.cipherKey << std::endl;
		}
	}
	/*else
	{
		if (debug) { std::cout << "Population is empty" << std::endl; }
	}*/
}


void Genetic::displayCode()
{
	if (!cypheredMessage.empty())
	{
		for (int i = 0; i < cypheredMessage.size(); i++)
		{
			std::cout << "Block " << i << ": " << cypheredMessage.at(i) << std::endl;
		}
	}
}


void Genetic::displayBest()
{
	double bestFitness = bestFitnessInPopulation();
	int count = 0;
	while (count < population.size())
	{
		if (population.at(count).fitness == bestFitness)
		{
			std::cout << std::endl << "Key: " << population.at(count).cipherKey << " ciphers message of "
				<< std::endl << decipheredCode(population.at(count))
				<< std::endl << "English Key:   " << englishKey
				<< std::endl << "Generated Key: " << population.at(count).cipherKey << std::endl;
			break;
		}

		count++;
	}
}


std::vector<Member> Genetic::pmx(Member t1, Member t2)
{
	std::vector<Member> children;


	//randomly select a substring of both t1 and t2
	std::random_device device;
	std::mt19937 generator(device());
	std::uniform_int_distribution<int> distribution(0, 25);
	int locationOne = distribution(generator);
	int locationTwo = distribution(generator);
	int min, max;

	//make sure the substring is greater than zero and the two random numbers are in order
	while (locationOne == locationTwo)
	{
		locationOne = distribution(generator);
		locationTwo = distribution(generator);
	}
	if (locationOne < locationTwo)
	{
		min = locationOne;
		max = locationTwo;
	}
	else
	{
		max = locationOne;
		min = locationTwo;
	}


	std::vector<char> t1map;
	std::vector<char> t2map;

	if (debugPMX)
	{
		std::cout << "t1 cipher key before crossover: " << t1.cipherKey << std::endl;
		std::cout << "t2 cipher key before crossover: " << t2.cipherKey << std::endl;
	}

	//swap the two substrings of t1 and t2
	std::string subt1 = "";
	std::string subt2 = "";
	for (int i = min; i < max; i++)
	{
		subt1 += t1.cipherKey.at(i);
		subt2 += t2.cipherKey.at(i);

		char currentTemp = t1.cipherKey.at(i);
		t1.cipherKey.at(i) = t2.cipherKey.at(i);
		t2.cipherKey.at(i) = currentTemp;

		//draw relationships between 2 strings
		t1map.push_back(t1.cipherKey.at(i));
		t2map.push_back(t2.cipherKey.at(i));
	}


	if (debugPMX)
	{
		std::cout << "Substrings t1 (" << subt1 << ") and t2 (" << subt2 << ") swapped, elements " << min << " to " << max << std::endl;

		std::cout << "t1 cipher key during crossover: " << t1.cipherKey << std::endl;
		std::cout << "t2 cipher key during crossover: " << t2.cipherKey << std::endl;
	}



	//check for duplicates by "mapping" what the flipped value was and replacing it
	for (int removeDuplicates = 0; removeDuplicates < 3; removeDuplicates++)
	{
		for (int i = 0; i < min; i++)
		{
			for (int mapSpot = 0; mapSpot < t1map.size(); mapSpot++)
			{
				//if the cipher contains a duplicate value that should not be there, replace it with the mapped relationship value
				if (t1.cipherKey.at(i) == t1map.at(mapSpot))
				{
					//std::cout << "Match found @ element " << i << " - Element " << t1.cipherKey.at(i) << " should be replaced" << std::endl;
					t1.cipherKey.at(i) = t2map.at(mapSpot);
				}

				if (t2.cipherKey.at(i) == t2map.at(mapSpot))
				{
					//std::cout << "Match found @ element " << i << " - Element " << t1.cipherKey.at(i) << " should be replaced" << std::endl;
					t2.cipherKey.at(i) = t1map.at(mapSpot);
				}
			}
		}



		for (int i = max; i < 26; i++)
		{
			for (int mapSpot = 0; mapSpot < t1map.size(); mapSpot++)
			{
				//if the cipher contains a duplicate value that should not be there, replace it with the mapped relationship value
				if (t1.cipherKey.at(i) == t1map.at(mapSpot))
				{
					//std::cout << "Match found @ element " << i << " - Element " << t1.cipherKey.at(i) << " should be replaced" << std::endl;
					t1.cipherKey.at(i) = t2map.at(mapSpot);
				}

				if (t2.cipherKey.at(i) == t2map.at(mapSpot))
				{
					//std::cout << "Match found @ element " << i << " - Element " << t1.cipherKey.at(i) << " should be replaced" << std::endl;
					t2.cipherKey.at(i) = t1map.at(mapSpot);
				}
			}
		}
	}

	if (debugPMX)
	{
		std::cout << "t1 cipher key after crossover: " << t1.cipherKey << std::endl;
		std::cout << "t2 cipher key after crossover: " << t2.cipherKey << std::endl << std::endl;
	}

	t1.checkDuplicates();
	t2.checkDuplicates();

	//push back both children so that they can be used in the algorithm
	children.push_back(t1);
	children.push_back(t2);


	return children;
}


std::vector<Member> Genetic::selectBest()
{
	std::vector<Member> topTwo;

	double bestFitness = population.at(0).fitness;
	double nextBestFitness = population.at(1).fitness;
	int bestLocation = 0;
	int nextBestLocation = 1;

	for (int i = 0; i < population.size(); i++)
	{
		double currentFitness = population.at(i).fitness;


		//best member
		if (currentFitness < bestFitness)
		{
			//move the current best to second best 
			nextBestFitness = bestFitness;
			nextBestLocation = bestLocation;

			//then update and set best member
			bestFitness = currentFitness;
			bestLocation = i;
		}


		//second best member
		if (currentFitness < nextBestFitness && currentFitness > bestFitness)
		{
			nextBestFitness = currentFitness;
			nextBestLocation = i;
		}
	}


	//once the best members have been found, add them and return them
	topTwo.push_back(population.at(bestLocation));
	topTwo.push_back(population.at(nextBestLocation));
	return topTwo;
}